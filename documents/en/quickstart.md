# Introduction
A short descrioption how to use _igorconsole_.

The igorconsole is a python package to **control Igor Pro application on Windows**.
This package is not designed for the stand alone manipulation of the igor pxp/ibw file.
For this purpose, I recommend you to use [igor](https://pypi.python.org/pypi/igor) alternatively.

The main target of this package is:
1.  those who want to store hierarchical data obtained/created on python to Igor pro.
2.  those who want make nice graphs using graphical interface on igor.
3.  those who want to combine powerful analysis tools supplied on python and Igor pro.

This package enables you to access Igor pro features and data stored on it seamlessly from python like numpy interface.

# Requirements
This support only python 3.4 or newer on Windows.
Igor pro 6.x or 7.x must be installed.
This package requires Numpy and Pywin32.
Pandas and Pillow are optionally supported for data conversion or plotting graph on Jupyter.

This package is tested on the latest stable version of python and Igor pro 7.

# Attention
Since the main purpose of this package is to offer a numpy-like interface to igor, the sopport of the some important feature of igor wave is not enough at this point.

Operation of *units of waves* or *scaling of waves* might be lost or behaves differently from the igor native behavior during the operation.

# Setup
> pip install igorconsole--version--.whl

# Preparation
```python
import igorconsole
igor = igorconsole.start()
```
This allows to connect to the existing Igor pro instance.
The program of Igor pro will get automatically runned when not runnning.

# Basic operation
```python
command = "Make testwave; testwave = x; Display testwave" #any igor command
histories, results = igor.execute(command)
```
This description allows to access almost all functions of Igor pro.
The _command_ accepts basic command which can be runned from the Command Window on Igor pro, and `if` sentence, `for` sentence, and so on cannot be included.
The return value `histories` is a list of history genearted during the execution.
The another return value `results` is a list of string generated by `sprintf 0` operation in the command; read igor mannual about this.

If you do not need return values, you can just execute command like:
```python
igor.execute(command)
```

# Data operation
You can access to Igor _root folder_ by
```python
igor.root
```
and _current working directory_ by
```python
igor.cwd
```
These two property return _Folder_ objects.

## Folder opearation
### Accessing subfolders
You can access a specific subfolder by
```python
igor.root.subfolders["folder_name"]
```
or shortly
```python
igor.root.f["folder_name"]
```
These operation is recursive, like:
```python
igor.root.f["subfolder"].f["subsubfolder"]
```

The `ForderCollection` object created by `Folder.subfolders` is iterable and you can access all subfolders in the particular parent folder by _for_ sentence.
This operation is explained later.
 
### Making subfolders
You can make a folder by
```python
igor.root.make_folder("folder_name", overwrite=False) # overwrite: False is default
```
### Change current working directory
You can change current directory to ":root:subfolder:subsubfolder" by
```python
igor.root.f["subfolders"].f["subsubfolder"].chdir()
```
## Wave operation
The _Wave_ object allows seamless access to igor wave by numpy-like interface.
Before codes below numpy is implistly imported by
```python
import numpy as np
``` 
### Accessing waves
You can access a specific subfolder by
```python
igor.root.waves["wave_name"]
```
or shortly
```python
igor.root.w["wave_name"]
```
### Creating wave
You can create wave leke followings:
```python
igor.root.w["wave1"] = [0.0, 1.0, 2.0, 3.0, 4.0]
igor.root.w["wave2"] = np.arange(5, dtype=np.float)
```

### Append values to wave
You can make a empty waves, and append values after that.
```python
igor.root.w["appendable"] = []
for i in range(10):
    igor.root.w["appendable"].append(i)
```
The `Wave.append` method accsepts list, tuple, or np.ndarray, so you can append multiple values like;
```python
igor.root.w["appendlist"] = [1,2,3]
igor.root.w["appendlist"].append([4,5,6])
# igor.root.w["appendlist"] -> [1,2,3,4,5,6]
```

__Appending a value to large wave (length > 30 000) is sometimes very slow. The best practice of appending values will be explained in another page.__

### Convert to python objects
You can to convert Igor `Wave` objects to python `list`, `np.ndarray`, or `pandas.Series` as followings:
```python
igor.root.a = [1,2,3,4,5]

#to list
igor.root.a.tolist()

#to np.ndarray
igor.root.a.array
#or
np.asarray(igor.root.a)

#to pandas.Series
igor.root.a.to_Series()
#This operation requires pandas to be installed.
```
### Calculation of wave
I offered the numpy-like vectrozed calculation interface to Igor wave.
The fllowings are the examples.

Scalar and Wave
```python
igor.root.a = np.array([1,2,3,4,5], dtype=float)

igor.root.a + 2.3
#-> array([ 3.3,  4.3,  5.3,  6.3,  7.3])
1J + igor.root.a
#-> array([ 1.+1.j,  2.+1.j,  3.+1.j,  4.+1.j,  5.+1.j])
```

np.ndarray and Wave
```python
igor.root.a = np.array([1,2,3,4,5])

igor.root.a + np.arange(5)
#-> array([1, 3, 5, 7, 9])
1J + igor.root.a
#-> array([ 1.+0.j,  2.+1.j,  3.+2.j,  4.+3.j,  5.+4.j])
```

Wave and Wave
```python
igor.root.a = np.array([1,2,3,4,5], dtype=float)
igor.root.b = igor.root.a # duplicated.

np.dot(igor.root.a, igor.root.b)
#-> 55.0

igor.root.a * igor.root.b
#-> array([  1.,   4.,   9.,  16.,  25.])

igor.root.c = igor.root.a*2 + igor.root.b + np.arange(5)
igor.root.c.array
#-> array([  3.,   7.,  11.,  15.,  19.])

igor.root.a == igor.root.b
#-> array([ True,  True,  True,  True,  True], dtype=bool)

igor.root.a /= igor.root.b
igor.root.a.array
#-> array([ 1.,  1.,  1.,  1.,  1.])
```

### Indexing
Igor wave supports, basic indexing, slice, bool index, and fancy index.

Basic index
```python
igor.root.a = np.arange(100).reshape(10, 10)

igor.root.a[5]
#-> array([50, 51, 52, 53, 54, 55, 56, 57, 58, 59])

igor.root.a[5,5]
#-> 55

igor.root.a[5][5]
#-> 55
```

Slice
```python
igor.root.a = np.arange(100).reshape(10, 10)

igor.root.a[2:-1, 3:5]
#->  array([[23, 24],
#        [33, 34],
#        [43, 44],
#        [53, 54],
#        [63, 64],
#        [73, 74],
#        [83, 84]])
```

Bool index
```python
igor.root.a = np.arange(100).reshape(10, 10)

igor.root.a[igor.root.a % 2 == 0] #not implemented yet
# array([ 0,  2,  4,  6,  8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32,
#        34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66,
#        68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98])

igor.root.a[igor.root.a % 2 == 0] = 0
# array([[ 0,  1,  0,  3,  0,  5,  0,  7,  0,  9],
#        [ 0, 11,  0, 13,  0, 15,  0, 17,  0, 19],
#        [ 0, 21,  0, 23,  0, 25,  0, 27,  0, 29],
#        [ 0, 31,  0, 33,  0, 35,  0, 37,  0, 39],
#        [ 0, 41,  0, 43,  0, 45,  0, 47,  0, 49],
#        [ 0, 51,  0, 53,  0, 55,  0, 57,  0, 59],
#        [ 0, 61,  0, 63,  0, 65,  0, 67,  0, 69],
#        [ 0, 71,  0, 73,  0, 75,  0, 77,  0, 79],
#        [ 0, 81,  0, 83,  0, 85,  0, 87,  0, 89],
#        [ 0, 91,  0, 93,  0, 95,  0, 97,  0, 99]])
```

Fancy index
